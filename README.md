## Общи задачи

### Разглеждаме свързан списък представен по следния начин
template <class G>
struct Node {
    G key;
    Node<G>* next;
    Node(G key) : key(key), next(nullptr){};
};

#### L1 и L2 са свързани списъци, като елементите в тях са сортирани лексикографски. Да се реализира функция unionList, която да приема L1 и L2 като списъци и връща нов списък чийто елементи са същите от L1 и L2, сортирани лексикографски.

#### Node<G>*  toList(const int* arr, size_t size)
Получава указател към масив arr съдържащ size елемента и по него създава и връща свързан списък. Списъкът да има същите стойности като тези в масива, подредени в същия ред. Паметта за кутиите на списъка да се заделя с new.

#### void deleteList(Node<G>* lst)
Освобождава (с delete) паметта заета от списъка lst.

#### void removeConsecutiveDuplicates(Node<G>* lst)
Премахва всички последователни повторения на елементи от списъка lst. Премахнатите елементи да се унищожават с delete. Например, нека е дадена редицата:
1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2
След премахване на последователните повторения от нея ще останат само:
1, 2, 1, 2, 1, 2, 1, 2



### https://docs.google.com/document/d/16ZRgs2kk-KDxv5kt8IOdtQDW_cWyd_YK5oBcWAewjVg/edit
